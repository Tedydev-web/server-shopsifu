name: üöÄ Deploy to Production

on:
  workflow_run:
    workflows: ['üèóÔ∏è Build Docker Image']
    types: [completed]
    branches: [master] # Only master branch for production
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (optional)'
        required: false
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: tedydev-web/server-shopsifu
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USERNAME: ${{ secrets.VPS_USERNAME }}
  VPS_PATH: ${{ secrets.VPS_PATH }}

jobs:
  deploy:
    name: üöÄ Deploy Application
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Reduced timeout for faster feedback
    # Only run if build workflow succeeded OR manual dispatch
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      deploy-time: ${{ steps.deploy-time.outputs.deploy-time }}
      deploy-status: ${{ job.status }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: ‚è±Ô∏è Start deploy timer
        id: deploy-timer
        run: echo "start_time=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: üîç Validate deployment inputs
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual deployment triggered"
            echo "Image tag: ${{ github.event.inputs.image_tag }}"
          else
            echo "Automatic deployment from build workflow"
          fi

      - name: üê≥ Deploy with Docker Compose
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          timeout: 60s
          command_timeout: 300s
          script: |
            set -euo pipefail

            # Debug environment variables
            echo "üîç Debug: Current working directory: $(pwd)"
            echo "üîç Debug: VPS_PATH from env: ${{ env.VPS_PATH }}"
            echo "üîç Debug: VPS_PATH from secrets: ${{ secrets.VPS_PATH }}"

            # Set VPS_PATH explicitly
            VPS_PATH="${VPS_PATH:-shopsifu/server-shopsifu}"
            echo "üîç Debug: Final VPS_PATH: $VPS_PATH"

            # Change to correct directory
            cd "$VPS_PATH" || {
              echo "‚ùå Failed to change to directory: $VPS_PATH"
              echo "üìÅ Available directories:"
              ls -la
              exit 1
            }

            echo "‚úÖ Changed to directory: $(pwd)"
            echo "üìÅ Directory contents:"
            ls -la

            echo "üöÄ Starting deployment process..."

            # Login to GHCR
            echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin

            # Stop existing services
            echo "üõë Stopping existing services..."
            docker compose down

            # Pull latest images from GHCR
            echo "üì• Pulling latest images from GitHub Container Registry..."
            docker compose pull

            # Deploy with Docker Compose
            echo "üöÄ Deploying with Docker Compose..."
            docker compose up -d

            # Verify deployment with better health check
            echo "üîç Verifying deployment..."
            echo "‚è≥ Waiting for services to start..."

            # Wait for services to be ready
            for i in {1..10}; do
              if docker compose ps | grep -q "shopsifu_server.*Up"; then
                echo "‚úÖ Service is running (attempt $i/10)"
                break
              fi
              echo "‚è≥ Service not ready yet (attempt $i/10)..."
              sleep 3
            done

            # Final verification
            if ! docker compose ps | grep -q "shopsifu_server.*Up"; then
              echo "‚ùå Deployment verification failed after 10 attempts"
              echo "üìä Current service status:"
              docker compose ps
              exit 1
            fi
            echo "‚úÖ Deployment verification passed"

            # Show service status
            echo "üìä Service status:"
            docker compose ps

      - name: üìä Calculate deploy time
        id: deploy-time
        run: |
          DEPLOY_END=$(date +%s)
          DEPLOY_START=${{ steps.deploy-timer.outputs.start_time }}
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))
          echo "deploy-time=$DEPLOY_DURATION" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Deploy completed in ${DEPLOY_DURATION}s"

  notification:
    name: üì¢ Send Notification
    needs: [deploy]
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: always()
    steps:
      - name: üì• Checkout repository for commit info
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üì¢ Send Discord notification
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          timeout: 60s
          command_timeout: 120s
          script: |
            set -euo pipefail

            # Set environment variables
            export DISCORD_WEBHOOK="${{ secrets.DISCORD_WEBHOOK }}"
            export STATUS="${{ needs.deploy.outputs.deploy-status == 'success' && 'success' || 'failure' }}"
            export BRANCH="${{ github.ref_name }}"
            export ACTOR="${{ github.actor }}"
            export COMMIT_SHA="${{ github.sha }}"

            # Get commit message and date from different sources
            if [ "${{ github.event_name }}" = "workflow_run" ]; then
              # For workflow_run events, try to get info from the triggering workflow
              export COMMIT_MESSAGE="${{ github.event.workflow_run.head_commit.message || 'Deployment from build workflow' }}"
              export COMMIT_DATE="${{ github.event.workflow_run.head_commit.timestamp || github.event.workflow_run.created_at || '' }}"
            else
              # For manual dispatch or other events
              export COMMIT_MESSAGE="${{ github.event.head_commit.message || 'Manual deployment' }}"
              export COMMIT_DATE="${{ github.event.head_commit.timestamp || '' }}"
            fi

            export REPO="${{ github.repository }}"
            export RUN_ID="${{ github.run_id }}"
            export DEPLOY_TIME="${{ needs.deploy.outputs.deploy-time || 'N/A' }}"

            # Change to project directory
            cd "${{ env.VPS_PATH }}" || exit 1

            # Install jq if not present
            sudo apt-get update -qq
            sudo apt-get install -y -qq jq

            # Get commit information
            COMMIT_SHORT_SHA=$(echo "$COMMIT_SHA" | cut -c1-7)

            # Get commit list (all commits in this push) - fallback to recent commits if git log fails
            COMMIT_LIST=$(git log --oneline --no-merges --since="1 hour ago" | head -10 | sed 's/^/‚Ä¢ /' 2>/dev/null || echo "‚Ä¢ Recent commits (git log unavailable)")

            # Get changes summary (last 10 commits) - fallback if git log fails
            CHANGES_SUMMARY=$(git log --stat --oneline -10 | grep -E "^ [0-9]+ files? changed" | tail -1 2>/dev/null || echo "Changes detected (git log unavailable)")

            # Get Docker status with NAME, CREATED, STATUS, PORTS
            DOCKER_STATUS=$(docker ps --format "table {{.Names}}\t{{.CreatedAt}}\t{{.Status}}\t{{.Ports}}" | head -10 2>/dev/null || echo "Docker status unavailable")

            # Get image info
            IMAGE_INFO=$(docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}" | grep "shopsifu" | head -5 2>/dev/null || echo "Image info unavailable")

            # Get system info
            SYSTEM_INFO=$(echo "CPU: $(nproc) cores | Memory: $(free -h | grep Mem | awk '{print $2}') | Disk: $(df -h / | tail -1 | awk '{print $4}') available" 2>/dev/null || echo "System info unavailable")

            # Get deployment environment info
            ENV_INFO=$(echo "Host: $(hostname) | OS: $(lsb_release -d | cut -f2) | Uptime: $(uptime -p)" 2>/dev/null || echo "Environment info unavailable")

            # Get network info
            NETWORK_INFO=$(echo "IP: $(hostname -I | awk '{print $1}') | Gateway: $(ip route | grep default | awk '{print $3}' | head -1)" 2>/dev/null || echo "Network info unavailable")

            COLOR=$([ "$STATUS" = "success" ] && echo 3066993 || echo 15158332)
            ICON=$([ "$STATUS" = "success" ] && echo "‚úÖ" || echo "‚ùå")
            DESCRIPTION=$([ "$STATUS" = "success" ] && echo "üöÄ **Deploy th√†nh c√¥ng**" || echo "‚ùå **Deploy th·∫•t b·∫°i**")

            # Handle empty values
            COMMIT_MESSAGE="${COMMIT_MESSAGE:-'Deployment from build workflow'}"
            COMMIT_DATE="${COMMIT_DATE:-$(date -u +"%Y-%m-%dT%H:%M:%SZ")}"
            DEPLOY_TIME="${DEPLOY_TIME:-'N/A'}"

            # Validate and sanitize values for JSON
            COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | tr -d '\n\r' | sed 's/"/\\"/g')
            COMMIT_DATE=$(echo "$COMMIT_DATE" | tr -d '\n\r')
            DEPLOY_TIME=$(echo "$DEPLOY_TIME" | tr -d '\n\r')
            COMMIT_LIST=$(echo "$COMMIT_LIST" | tr -d '\n\r' | sed 's/"/\\"/g')
            CHANGES_SUMMARY=$(echo "$CHANGES_SUMMARY" | tr -d '\n\r' | sed 's/"/\\"/g')
            DOCKER_STATUS=$(echo "$DOCKER_STATUS" | tr -d '\n\r' | sed 's/"/\\"/g')
            IMAGE_INFO=$(echo "$IMAGE_INFO" | tr -d '\n\r' | sed 's/"/\\"/g')
            SYSTEM_INFO=$(echo "$SYSTEM_INFO" | tr -d '\n\r' | sed 's/"/\\"/g')
            ENV_INFO=$(echo "$ENV_INFO" | tr -d '\n\r' | sed 's/"/\\"/g')
            NETWORK_INFO=$(echo "$NETWORK_INFO" | tr -d '\n\r' | sed 's/"/\\"/g')

            # Debug: Print sanitized values
            echo "üîç Debug: Sanitized values:"
            echo "  COMMIT_MESSAGE: $COMMIT_MESSAGE"
            echo "  COMMIT_DATE: $COMMIT_DATE"
            echo "  DEPLOY_TIME: $DEPLOY_TIME"
            echo "  SYSTEM_INFO: $SYSTEM_INFO"
            echo "  ENV_INFO: $ENV_INFO"
            echo "  NETWORK_INFO: $NETWORK_INFO"

            # Create a summary of all collected information
            echo "üìã Summary of collected information:"
            echo "  Status: $STATUS"
            echo "  Branch: $BRANCH"
            echo "  Actor: $ACTOR"
            echo "  Commit SHA: $COMMIT_SHORT_SHA"
            echo "  Commit Message: $COMMIT_MESSAGE"
            echo "  Commit Date: $COMMIT_DATE"
            echo "  Deploy Time: $DEPLOY_TIME"
            echo "  Repo: $REPO"
            echo "  Run ID: $RUN_ID"
            echo "  Discord Webhook: ${DISCORD_WEBHOOK:0:50}..."
            echo "  Total fields: 13"

            JSON_PAYLOAD=$(jq -n \
              --arg status "$STATUS" \
              --arg icon "$ICON" \
              --arg description "$DESCRIPTION" \
              --arg color "$COLOR" \
              --arg branch "$BRANCH" \
              --arg actor "$ACTOR" \
              --arg commit_sha "$COMMIT_SHORT_SHA" \
              --arg commit_message "$COMMIT_MESSAGE" \
              --arg commit_date "$COMMIT_DATE" \
              --arg changes_summary "$CHANGES_SUMMARY" \
              --arg commit_list "$COMMIT_LIST" \
              --arg docker_status "$DOCKER_STATUS" \
              --arg image_info "$IMAGE_INFO" \
              --arg system_info "$SYSTEM_INFO" \
              --arg deploy_time "$DEPLOY_TIME" \
              --arg repo "$REPO" \
              --arg run_id "$RUN_ID" \
              --arg env_info "$ENV_INFO" \
              --arg network_info "$NETWORK_INFO" \
              ' {
                  embeds: [{
                    title: "üöÄ SERVER - Deploy Production",
                    description: $description,
                    color: ($color | tonumber),
                    fields: [
                      { name: "üìä Tr·∫°ng th√°i", value: "\($icon) \($status | ascii_upcase)", inline: true },
                      { name: "üåø Nh√°nh", value: $branch, inline: true },
                      { name: "üë§ Ng∆∞·ªùi th·ª±c hi·ªán", value: $actor, inline: true },
                      { name: "üîó Commit SHA", value: "`\($commit_sha)`", inline: true },
                      { name: "üìÖ Commit Date", value: $commit_date, inline: true },
                      { name: "‚è±Ô∏è Deploy Time", value: $deploy_time, inline: true },
                      { name: "üìù Commit Message", value: $commit_message, inline: false },
                      { name: "üìä Changes Summary", value: $changes_summary, inline: false },
                      { name: "üìã Danh s√°ch Commits", value: $commit_list, inline: false },
                      { name: "üê≥ Docker Status", value: "```\($docker_status)```", inline: false },
                      { name: "üñºÔ∏è Image Info", value: "```\($image_info)```", inline: false },
                      { name: "üíª System Info", value: "```\($system_info)```", inline: false },
                      { name: "üåê M√¥i tr∆∞·ªùng", value: "```\($env_info)```", inline: false },
                      { name: "üåê M·∫°ng", value: "```\($network_info)```", inline: false }
                    ],
                    url: "https://github.com/\($repo)/actions/runs/\($run_id)",
                    footer: { "text": "üöÄ Deploy Production" },
                    timestamp: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
                  }]
                }')

            # Debug: Print JSON payload
            echo "üîç Debug: JSON Payload:"
            echo "$JSON_PAYLOAD"

            # Validate JSON payload
            if ! echo "$JSON_PAYLOAD" | jq . >/dev/null 2>&1; then
              echo "‚ùå Invalid JSON payload generated"
              echo "‚ùå JSON validation failed"
              echo "‚ùå Please check the generated JSON payload"
              exit 1
            fi

            # Check JSON payload size (Discord has a limit of 6000 characters for embeds)
            PAYLOAD_SIZE=$(echo "$JSON_PAYLOAD" | wc -c)
            if [ "$PAYLOAD_SIZE" -gt 5000 ]; then
              echo "‚ö†Ô∏è Warning: JSON payload is large ($PAYLOAD_SIZE bytes)"
              echo "‚ö†Ô∏è Discord has embed limits, some content may be truncated"
            fi

            # Validate Discord webhook URL
            if [[ ! "$DISCORD_WEBHOOK" =~ ^https://discord\.com/api/webhooks/[0-9]+/[a-zA-Z0-9_-]+$ ]]; then
              echo "‚ùå Invalid Discord webhook URL format"
              echo "‚ùå Expected format: https://discord.com/api/webhooks/[ID]/[TOKEN]"
              exit 1
            fi

            # Send to Discord with retry logic
            MAX_RETRIES=3
            for i in $(seq 1 $MAX_RETRIES); do
              echo "üîÑ Attempting to send Discord notification (attempt $i/$MAX_RETRIES)..."
              echo "üîó Discord webhook: ${DISCORD_WEBHOOK:0:50}..."
              echo "üì¶ Payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"

              RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Content-Type: application/json" -X POST -d "$JSON_PAYLOAD" "$DISCORD_WEBHOOK")
              HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
              RESPONSE_BODY=$(echo "$RESPONSE" | grep -v "HTTP_STATUS:")

              echo "üîç Debug: HTTP Status: $HTTP_STATUS"
              echo "üîç Debug: Response Body: $RESPONSE_BODY"

              if [ "$HTTP_STATUS" = "204" ] || [ "$HTTP_STATUS" = "200" ]; then
                echo "‚úÖ Discord notification sent successfully (HTTP $HTTP_STATUS)"
                echo "‚úÖ Notification sent to Discord channel"
                echo "‚úÖ Payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"
                echo "‚úÖ Response: $RESPONSE_BODY"
                break
              else
                echo "‚ö†Ô∏è Attempt $i/$MAX_RETRIES failed (HTTP $HTTP_STATUS)"
                echo "‚ö†Ô∏è Response: $RESPONSE_BODY"
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "‚è≥ Waiting 2 seconds before retry..."
                  sleep 2
                else
                  echo "‚ùå Failed to send Discord notification after $MAX_RETRIES attempts"
                  echo "‚ùå Last response: $RESPONSE_BODY"
                  echo "‚ùå Discord webhook URL: $DISCORD_WEBHOOK"
                  echo "‚ùå Please check your Discord webhook configuration"
                  echo "‚ùå Payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"
                  echo "‚ùå HTTP Status: $HTTP_STATUS"
                  exit 1
                fi
              fi
            done

            echo "üéâ Discord notification process completed"
            echo "üìä Final status: $STATUS"
            echo "‚è±Ô∏è Total time: $DEPLOY_TIME"
            echo "üì¶ Final payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"
