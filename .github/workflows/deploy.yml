name: üöÄ Deploy to Production

on:
  workflow_run:
    workflows: ['üèóÔ∏è Build Docker Image']
    types: [completed]
    branches: [master] # Only master branch for production
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag to deploy (optional)'
        required: false
        default: 'latest'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: tedydev-web/server-shopsifu
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USERNAME: ${{ secrets.VPS_USERNAME }}
  VPS_PATH: ${{ secrets.VPS_PATH }}

jobs:
  deploy:
    name: üöÄ Deploy Application
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Reduced timeout for faster feedback
    # Only run if build workflow succeeded OR manual dispatch
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: ‚è±Ô∏è Start deploy timer
        id: deploy-timer
        run: echo "start_time=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: üîç Validate deployment inputs
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "Manual deployment triggered"
            echo "Image tag: ${{ github.event.inputs.image_tag }}"
          else
            echo "Automatic deployment from build workflow"
          fi

      - name: üê≥ Deploy with Docker Compose
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          timeout: 60s
          command_timeout: 300s
          script: |
            set -euo pipefail
            cd "${{ env.VPS_PATH }}"

            echo "üöÄ Starting deployment process..."

            # Login to GHCR
            echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin

            # Stop existing services
            echo "üõë Stopping existing services..."
            docker compose -f ${{ env.VPS_PATH }}/docker-compose.yml down

            # Pull latest images from GHCR
            echo "üì• Pulling latest images from GitHub Container Registry..."
            docker compose -f ${{ env.VPS_PATH }}/docker-compose.yml pull

            # Deploy with Docker Compose
            echo "üöÄ Deploying with Docker Compose..."
            docker compose -f ${{ env.VPS_PATH }}/docker-compose.yml up -d

            # Verify deployment with better health check
            echo "üîç Verifying deployment..."
            echo "‚è≥ Waiting for services to start..."

            # Wait for services to be ready
            for i in {1..10}; do
              if docker compose -f ${{ env.VPS_PATH }}/docker-compose.yml ps | grep -q "shopsifu_server.*Up"; then
                echo "‚úÖ Service is running (attempt $i/10)"
                break
              fi
              echo "‚è≥ Service not ready yet (attempt $i/10)..."
              sleep 3
            done

            # Final verification
                          if ! docker compose -f ${{ env.VPS_PATH }}/docker-compose.yml ps | grep -q "shopsifu_server.*Up"; then
                echo "‚ùå Deployment verification failed after 10 attempts"
                echo "üìä Current service status:"
                docker compose -f ${{ env.VPS_PATH }}/docker-compose.yml ps
              exit 1
            fi
            echo "‚úÖ Deployment verification passed"

            # Show service status
            echo "üìä Service status:"
            docker compose -f ${{ env.VPS_PATH }}/docker-compose.yml ps

      - name: üìä Calculate deploy time
        id: deploy-time
        run: |
          DEPLOY_END=$(date +%s)
          DEPLOY_START=${{ steps.deploy-timer.outputs.start_time }}
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))
          echo "deploy-time=$DEPLOY_DURATION" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Deploy completed in ${DEPLOY_DURATION}s"

  health-check:
    name: üè• Health Check
    needs: deploy
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: ‚è±Ô∏è Start health check timer
        id: health-timer
        run: echo "start_time=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: üè• Perform comprehensive health check
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          timeout: 120s
          command_timeout: 300s
          script: |
            set -euo pipefail

            echo "üè• Starting comprehensive health check..."

            # Install required tools
            sudo apt-get update -qq
            sudo apt-get install -y -qq jq netcat-openbsd postgresql-client redis-tools

            # Set environment variables
            export VPS_PATH="${{ env.VPS_PATH }}"
            export DISCORD_WEBHOOK="${{ secrets.DISCORD_WEBHOOK }}"

            # Run comprehensive health check script
            if [ -f "${{ env.VPS_PATH }}/scripts/comprehensive-health-check.sh" ]; then
              chmod +x "${{ env.VPS_PATH }}/scripts/comprehensive-health-check.sh"
              "${{ env.VPS_PATH }}/scripts/comprehensive-health-check.sh"
            else
              echo "‚ùå Comprehensive health check script not found"
              echo "üìä Falling back to basic health check..."

              # Basic health check fallback
              cd "${{ env.VPS_PATH }}"
              ATTEMPTS=30
              SLEEP=5
              TIMEOUT=10

              for i in $(seq 1 $ATTEMPTS); do
                echo "Attempt $i/$ATTEMPTS..."

                if ! docker compose -f "${{ env.VPS_PATH }}/docker-compose.yml" ps | grep -q "shopsifu_server.*Up"; then
                  echo "‚ö†Ô∏è Service not running yet, waiting..."
                  sleep $SLEEP
                  continue
                fi

                if timeout $TIMEOUT curl -fsS -m 5 http://localhost:3000/health > /dev/null; then
                  echo "‚úÖ Basic health check passed!"
                  exit 0
                else
                  echo "‚ö†Ô∏è Health check attempt $i failed, retrying..."
                  sleep $SLEEP
                fi
              done

              echo "‚ùå Basic health check failed after $ATTEMPTS attempts"
              docker compose -f "${{ env.VPS_PATH }}/docker-compose.yml" ps
              exit 1
            fi

      - name: üìä Calculate health check time
        id: health-time
        run: |
          HEALTH_END=$(date +%s)
          HEALTH_START=${{ steps.health-timer.outputs.start_time }}
          HEALTH_DURATION=$((HEALTH_END - HEALTH_START))
          echo "health-time=$HEALTH_DURATION" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Health check completed in ${HEALTH_DURATION}s"

  notification:
    name: üì¢ Send Notification
    needs: [deploy, health-check]
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: always()
    steps:
      - name: üì¢ Send Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          STATUS: ${{ needs.health-check.outcome == 'success' && 'success' || 'failure' }}
          BRANCH: main
          COMMIT: ${{ github.sha }}
          ACTOR: ${{ github.actor }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          DEPLOY_TIME: ${{ needs.deploy.outputs.deploy-time }}
          HEALTH_TIME: ${{ needs.health-check.outputs.health-time }}
        run: |
          sudo apt-get update && sudo apt-get install -y jq

          COLOR=$([ "$STATUS" = "success" ] && echo 3066993 || echo 15158332)
          ICON=$([ "$STATUS" = "success" ] && echo "‚úÖ" || echo "‚ùå")
          DESCRIPTION=$([ "$STATUS" = "success" ] && echo "üöÄ **Deploy th√†nh c√¥ng**" || echo "‚ùå **Deploy th·∫•t b·∫°i**")

          TOTAL_TIME=$((DEPLOY_TIME + HEALTH_TIME))

          JSON_PAYLOAD=$(jq -n \
            --arg status "$STATUS" \
            --arg icon "$ICON" \
            --arg description "$DESCRIPTION" \
            --arg color "$COLOR" \
            --arg deploy_time "$DEPLOY_TIME" \
            --arg health_time "$HEALTH_TIME" \
            --arg total_time "$TOTAL_TIME" \
            --arg repo "$REPO" \
            --arg run_id "$RUN_ID" \
            ' {
                embeds: [{
                  title: "üöÄ SERVER - Deploy Production",
                  description: $description,
                  color: ($color | tonumber),
                  fields: [
                    { name: "üìä Tr·∫°ng th√°i", value: "\($icon) \($status | ascii_upcase)", inline: true },
                    { name: "‚è±Ô∏è Performance", value: "Deploy: \($deploy_time)s\nHealth: \($health_time)s\n**Total: \($total_time)s**", inline: false }
                  ],
                  url: "https://github.com/\($repo)/actions/runs/\($run_id)",
                  footer: { "text": "üöÄ Deploy Production" },
                  timestamp: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
                }]
              }')

          curl -s -H "Content-Type: application/json" -X POST -d "$JSON_PAYLOAD" "$DISCORD_WEBHOOK" || echo "L·ªói g·ª≠i th√¥ng b√°o Discord"
