name: üöÄ Build and Deploy Production

on:
  push:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      manual_rollback:
        description: 'Commit SHA ho·∫∑c tag ƒë·ªÉ rollback'
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: tedydev-web/server-shopsifu
  PROJECT_NAME: server-shopsifu
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USERNAME: ${{ secrets.VPS_USERNAME }}
  VPS_PATH: ${{ secrets.VPS_PATH }}
  VPS_PORT: '22'
  VPS_FINGERPRINT: ''

# ==============================================
# REUSABLE WORKFLOW FUNCTIONS
# ==============================================
jobs:
  # ==============================================
  # SECURITY SCANNING
  # ==============================================
  security-scan:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: read
      security-events: write
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: üìä Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: üö® Check for high severity vulnerabilities
        run: |
          if [ -f "trivy-results.sarif" ]; then
            HIGH_VULNS=$(grep -c '"level": "error"' trivy-results.sarif || echo "0")
            if [ "$HIGH_VULNS" -gt 0 ]; then
              echo "‚ùå Found $HIGH_VULNS high severity vulnerabilities"
              exit 1
            else
              echo "‚úÖ No high severity vulnerabilities found"
            fi
          fi

  # ==============================================
  # BUILD DOCKER IMAGE
  # ==============================================
  build:
    name: üèóÔ∏è Build Docker Image
    needs: security-scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
      build-status: ${{ job.status }}
      build-time: ${{ steps.build.outputs.build-time }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîê Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.created=${{ steps.prep.outputs.date }}

      - name: üê≥ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:v0.12.0
            network=host

      - name: üìä Prepare build metadata
        id: prep
        shell: bash
        run: |
          echo "date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "$GITHUB_OUTPUT"
          echo "version=${GITHUB_REF_NAME:-unknown}" >> "$GITHUB_OUTPUT"
          echo "short_sha=${GITHUB_SHA::7}" >> "$GITHUB_OUTPUT"
          echo "build_start=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: üöÄ Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        continue-on-error: false
        with:
          context: .
          file: ./Dockerfile
          pull: true
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            BUILD_VERSION=${{ steps.prep.outputs.version }}
            BUILD_DATE=${{ steps.prep.outputs.date }}
            GIT_SHA=${{ github.sha }}
          # Temporarily disable cache due to GitHub Actions Cache service issues
          # This will be re-enabled once GitHub fixes their cache service
          # cache-from: type=gha,scope=${{ github.workflow }}-${{ github.ref }}
          # cache-to: type=gha,mode=max,scope=${{ github.workflow }}-${{ github.ref }}
          platforms: linux/amd64
          provenance: false
          sbom: false
          outputs: type=image,compression=gzip

      - name: üìä Calculate build time
        id: build-time
        run: |
          BUILD_END=$(date +%s)
          BUILD_START=${{ steps.prep.outputs.build_start }}
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          echo "build-time=$BUILD_DURATION" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Build completed in ${BUILD_DURATION}s"

      - name: üßπ Cleanup build cache
        if: always()
        run: |
          docker builder prune -f
          docker system prune -f

      - name: ‚úÖ Verify Docker images
        if: always()
        run: |
          # Verify that images were pushed successfully
          echo "üîç Verifying Docker images..."

          # Check if we have tags and images were pushed
          if [ -n "${{ steps.meta.outputs.tags }}" ]; then
            echo "‚úÖ Docker build completed successfully"
            echo "Images pushed to GHCR:"
            echo "${{ steps.meta.outputs.tags }}"

            # Check if we have digest (optional)
            if [ -n "${{ steps.build.outputs.digest }}" ]; then
              echo "Image digest: ${{ steps.build.outputs.digest }}"
            else
              echo "‚ö†Ô∏è  Image digest not available (cache export failed)"
            fi

            # Mark build as successful since images were pushed
            echo "‚úÖ Build verification passed - proceeding to deploy"
            exit 0
          else
            echo "‚ùå Docker build failed - no image tags found"
            exit 1
          fi

  # ==============================================
  # DEPLOY TO PRODUCTION VPS
  # ==============================================
  deploy:
    name: üöÄ Deploy to Production
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: read
    outputs:
      deploy-status: ${{ job.status }}
      deploy-time: ${{ steps.deploy-time.outputs.deploy-time }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîß Setup VPS Performance
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            export PROJECT_PATH='${{ env.VPS_PATH }}'
            set -euo pipefail
            cd "$PROJECT_PATH"

            # Setup kernel performance tuning (requires sudo access without password)
            sudo tee /etc/sysctl.d/90-shopsifu-performance.conf >/dev/null <<'EOF'
            vm.max_map_count = 262144
            fs.file-max = 1048576
            net.core.somaxconn = 16384
            EOF
            sudo sysctl --system || true

      - name: üîÑ Sync repository
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            export PROJECT_PATH='${{ env.VPS_PATH }}'
            set -euo pipefail
            cd "$PROJECT_PATH"

            # Sync with current branch
            BRANCH='${{ github.ref_name }}'
            git fetch --prune --tags origin "$BRANCH"
            git reset --hard "origin/$BRANCH"

      - name: ‚è±Ô∏è Start deploy timer
        id: deploy-timer
        run: echo "start_time=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: üê≥ Deploy application
        id: deploy-app
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ env.VPS_PORT && env.VPS_PORT || '22' }}
          # passphrase: ${{ secrets.VPS_SSH_PASSPHRASE }}
          # fingerprint: ${{ env.VPS_FINGERPRINT }}
          debug: true
          script: |
            export PROJECT_PATH='${{ env.VPS_PATH }}'
            set -euo pipefail
            cd "$PROJECT_PATH"

            # Login to GHCR
            echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin

            # Use pinned image digest if available, otherwise fallback to branch tag
            DIGEST='${{ needs.build.outputs.image-digest }}'
            if [ -n "$DIGEST" ]; then
              export SERVER_IMAGE="ghcr.io/${{ env.IMAGE_NAME }}@$DIGEST"
            else
              export SERVER_IMAGE="ghcr.io/${{ env.IMAGE_NAME }}:${{ github.ref_name }}"
            fi
            echo "üöÄ Deploying image: $SERVER_IMAGE"

                        # Deploy with Docker Compose using .env.docker file
            docker compose --env-file .env.docker config -q

            # Pull images with increased timeout and retry
            echo "üîÑ Pulling Docker images..."
            docker compose --env-file .env.docker pull --quiet || {
              echo "‚ö†Ô∏è First pull attempt failed, retrying..."
              sleep 10
              docker compose --env-file .env.docker pull --quiet
            }

            # Check and kill processes using conflicting ports
            echo "üîç Checking for port conflicts..."
            if lsof -ti:6379 >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Port 6379 (Redis) is in use, killing conflicting processes..."
              lsof -ti:6379 | xargs kill -9 || true
              sleep 2
            fi

            if lsof -ti:5432 >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Port 5432 (PostgreSQL) is in use, killing conflicting processes..."
              lsof -ti:5432 | xargs kill -9 || true
              sleep 2
            fi

            if lsof -ti:3000 >/dev/null 2>&1; then
              echo "‚ö†Ô∏è Port 3000 (Server) is in use, killing conflicting processes..."
              lsof -ti:3000 | xargs kill -9 || true
              sleep 2
            fi

            echo "üöÄ Starting containers..."
            docker compose --env-file .env.docker up -d --force-recreate --remove-orphans

      - name: üßπ Cleanup old images
        if: always()
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -euo pipefail
            # Clean old images (keep last 7 days)
            docker image prune -af --filter "until=168h" || true

      - name: üìä Calculate deploy time
        id: deploy-time
        run: |
          DEPLOY_END=$(date +%s)
          DEPLOY_START=${{ steps.deploy-timer.outputs.start_time }}
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))
          echo "deploy-time=$DEPLOY_DURATION" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Deploy completed in ${DEPLOY_DURATION}s"

  # ==============================================
  # HEALTH CHECK & MONITORING
  # ==============================================
  health-check:
    name: üè• Health Check
    needs: deploy
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      health-status: ${{ job.status }}
      health-time: ${{ steps.health-time.outputs.health-time }}
    steps:
      - name: ‚è±Ô∏è Start health check timer
        id: health-timer
        run: echo "start_time=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: üìä Internal health check
        id: internal_health
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -euo pipefail
            ATTEMPTS=20
            SLEEP=6

            echo "üè• Starting health check..."
            HEALTH_START=$(date +%s)

            for i in $(seq 1 $ATTEMPTS); do
              echo "Attempt $i/$ATTEMPTS..."
              CODE=$(curl -fsS -m 5 -o /dev/null -w "%{http_code}" http://localhost:3000/health || echo "000")
              if [ "$CODE" -ge 200 ] && [ "$CODE" -lt 300 ]; then
                HEALTH_END=$(date +%s)
                HEALTH_DURATION=$((HEALTH_END - HEALTH_START))
                echo "‚úÖ Health check passed with code $CODE in ${HEALTH_DURATION}s"
                echo "health_duration=$HEALTH_DURATION" >> "$GITHUB_OUTPUT"
                exit 0
              fi
              sleep $SLEEP
            done

            echo "‚ùå Health check failed after $ATTEMPTS attempts"
            exit 1

      - name: üåê External health check
        id: external_health
        continue-on-error: true
        run: |
          set -euo pipefail

          URL="https://api.shopsifu.live/health"
          echo "üåê External healthcheck URL: $URL"

          ATTEMPTS=20
          SLEEP=6
          PASS=0

          for i in $(seq 1 $ATTEMPTS); do
            echo "Attempt $i/$ATTEMPTS..."
            CODE=$(curl -fsS -m 5 -o /dev/null -w "%{http_code}" "$URL" || echo "000")
            if [ "$CODE" -ge 200 ] && [ "$CODE" -lt 300 ]; then
              PASS=1
              break
            fi
            sleep $SLEEP
          done

          if [ "$PASS" -eq 1 ]; then
            echo "result=success" >> $GITHUB_OUTPUT
            echo "‚úÖ External health check passed with code $CODE"
          else
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è External health check failed (may be due to WAF)"
          fi

      - name: üìä Calculate health check time
        id: health-time
        run: |
          HEALTH_END=$(date +%s)
          HEALTH_START=${{ steps.health-timer.outputs.start_time }}
          HEALTH_DURATION=$((HEALTH_END - HEALTH_START))
          echo "health-time=$HEALTH_DURATION" >> "$GITHUB_OUTPUT"
          echo "‚è±Ô∏è Health check completed in ${HEALTH_DURATION}s"

  # ==============================================
  # NOTIFICATION & REPORTING
  # ==============================================
  notification:
    name: üì¢ Send Notifications
    needs: [build, deploy, health-check]
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: always()
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìä Generate deployment report
        id: report
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          # Fetch full history
          git fetch --prune --unshallow || true
          git fetch --all --tags || true

          CURRENT_SHA="${{ github.sha }}"
          BEFORE_SHA="${{ github.event.before }}"

          # Fallback for BEFORE_SHA
          if [ -z "$BEFORE_SHA" ] || ! git rev-parse --verify "$BEFORE_SHA^{commit}" >/dev/null 2>&1; then
            BEFORE_SHA=$(git rev-parse "$CURRENT_SHA^" 2>/dev/null || echo "")
          fi

          # Get commit details
          COMMIT_MESSAGE=$(git log -1 --pretty=format:"%s" "$CURRENT_SHA" || true)
          COMMIT_AUTHOR=$(git log -1 --pretty=format:"%an" "$CURRENT_SHA" || true)
          COMMIT_DATE=$(git log -1 --pretty=format:"%cd" --date=iso-strict "$CURRENT_SHA" || date -u +%Y-%m-%dT%H:%M:%SZ)

          # Generate commit range
          COMMIT_RANGE=""
          if [ -n "$BEFORE_SHA" ]; then
            COMMIT_RANGE=$(git rev-list --reverse "$BEFORE_SHA..$CURRENT_SHA" 2>/dev/null || echo "")
          fi

          COMMIT_LOG=""
          if [ -n "$COMMIT_RANGE" ]; then
            while read -r SHA; do
              [ -z "$SHA" ] && continue
              MSG=$(git log -1 --pretty=format:"%s" "$SHA")
              AUTHOR=$(git log -1 --pretty=format:"%an" "$SHA")
              COMMIT_LOG+="- [\`$(echo "$SHA" | cut -c1-7)\`](https://github.com/${{ github.repository }}/commit/$SHA) $MSG ‚Äî _${AUTHOR}_\n"
            done <<< "$COMMIT_RANGE"
          else
            SHORT=$(echo "$CURRENT_SHA" | cut -c1-7)
            COMMIT_LOG="- [\`$SHORT\`](https://github.com/${{ github.repository }}/commit/$CURRENT_SHA) $COMMIT_MESSAGE ‚Äî _${COMMIT_AUTHOR}_\n"
          fi

          echo "message=$COMMIT_MESSAGE" >> $GITHUB_OUTPUT
          echo "author=$COMMIT_AUTHOR" >> $GITHUB_OUTPUT
          echo "date=$COMMIT_DATE" >> $GITHUB_OUTPUT
          echo "log<<EOF" >> $GITHUB_OUTPUT
          echo -e "$COMMIT_LOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üìã Job Summary
        env:
          STATUS: ${{ needs.health-check.outcome == 'success' && 'success' || 'failure' }}
          BRANCH: ${{ github.ref_name }}
          COMMIT: ${{ github.sha }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          IMAGE_TAGS: ${{ needs.build.outputs.image-tag }}
          IMAGE_DIGEST: ${{ needs.build.outputs.image-digest }}
          COMMITS_BLOCK: ${{ steps.report.outputs.log }}
          BUILD_TIME: ${{ needs.build.outputs.build-time }}
          DEPLOY_TIME: ${{ needs.deploy.outputs.deploy-time }}
          HEALTH_TIME: ${{ needs.health-check.outputs.health-time }}
        run: |
          {
            echo "# üöÄ Deploy Summary"
            echo
            echo "**Status:** ${STATUS^^}"
            echo
            echo "**Repository:** $REPO"
            echo "**Branch:** `$BRANCH`"
            echo "**Run:** https://github.com/$REPO/actions/runs/$RUN_ID"
            echo
            echo "## ‚è±Ô∏è Performance Metrics"
            echo "- **Build Time:** ${BUILD_TIME}s"
            echo "- **Deploy Time:** ${DEPLOY_TIME}s"
            echo "- **Health Check:** ${HEALTH_TIME}s"
            echo "- **Total Time:** $((BUILD_TIME + DEPLOY_TIME + HEALTH_TIME))s"
            echo
            echo "## üîó Artifact"
            echo "- **Image Tags:** \`$IMAGE_TAGS\`"
            echo "- **Image Digest:** \`$IMAGE_DIGEST\`"
            echo
            echo "## üìö Commits"
            echo "$COMMITS_BLOCK"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: üì¢ Send Discord notification
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          STATUS: ${{ needs.health-check.outcome == 'success' && 'success' || 'failure' }}
          BRANCH: ${{ github.ref_name }}
          COMMIT: ${{ github.sha }}
          ACTOR: ${{ github.actor }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          COMMIT_MESSAGE: ${{ steps.report.outputs.message }}
          COMMIT_AUTHOR: ${{ steps.report.outputs.author }}
          COMMIT_DATE: ${{ steps.report.outputs.date }}
          IMAGE_TAGS: ${{ needs.build.outputs.image-tag }}
          IMAGE_DIGEST: ${{ needs.build.outputs.image-digest }}
          COMMIT_LOG: ${{ steps.report.outputs.log }}
          BUILD_TIME: ${{ needs.build.outputs.build-time }}
          DEPLOY_TIME: ${{ needs.deploy.outputs.deploy-time }}
          HEALTH_TIME: ${{ needs.health-check.outputs.health-time }}
        run: |
          sudo apt-get update && sudo apt-get install -y jq

          COLOR=$([ "$STATUS" = "success" ] && echo 3066993 || echo 15158332)
          ICON=$([ "$STATUS" = "success" ] && echo "‚úÖ" || echo "‚ùå")
          DESCRIPTION=$([ "$STATUS" = "success" ] && echo "üöÄ **Tri·ªÉn khai Production th√†nh c√¥ng**" || echo "‚ùå **Deployment th·∫•t b·∫°i**")

          # Commit type icon
          COMMIT_TYPE_ICON="üìù"
          case "$COMMIT_MESSAGE" in
            feat*) COMMIT_TYPE_ICON="‚ú®";;
            fix*) COMMIT_TYPE_ICON="üêõ";;
            docs*) COMMIT_TYPE_ICON="üìö";;
            style*) COMMIT_TYPE_ICON="üíÑ";;
            refactor*) COMMIT_TYPE_ICON="‚ôªÔ∏è";;
            test*) COMMIT_TYPE_ICON="üß™";;
            chore*) COMMIT_TYPE_ICON="üîß";;
            perf*) COMMIT_TYPE_ICON="‚ö°";;
            ci*) COMMIT_TYPE_ICON="üë∑";;
            build*) COMMIT_TYPE_ICON="üì¶";;
            revert*) COMMIT_TYPE_ICON="‚è™";;
            security*) COMMIT_TYPE_ICON="üîí";;
          esac

          COMMITS_BLOCK=${COMMIT_LOG:-"(kh√¥ng c√≥ d·ªØ li·ªáu commit)"}
          TOTAL_TIME=$((BUILD_TIME + DEPLOY_TIME + HEALTH_TIME))

          JSON_PAYLOAD=$(jq -n \
            --arg status "$STATUS" \
            --arg icon "$ICON" \
            --arg branch "$BRANCH" \
            --arg commit_short "$(echo $COMMIT | cut -c1-7)" \
            --arg commit_full "$COMMIT" \
            --arg repo "$REPO" \
            --arg actor "$ACTOR" \
            --arg run_id "$RUN_ID" \
            --arg color "$COLOR" \
            --arg description "$DESCRIPTION" \
            --arg commit_message "$COMMIT_TYPE_ICON $COMMIT_MESSAGE" \
            --arg commit_author "$COMMIT_AUTHOR" \
            --arg commit_date "$COMMIT_DATE" \
            --arg image_tags "$IMAGE_TAGS" \
            --arg image_digest "$IMAGE_DIGEST" \
            --arg commits_block "$COMMITS_BLOCK" \
            --arg build_time "$BUILD_TIME" \
            --arg deploy_time "$DEPLOY_TIME" \
            --arg health_time "$HEALTH_TIME" \
            --arg total_time "$TOTAL_TIME" \
            ' {
                embeds: [{
                  title: "üöÄ SERVER - Tri·ªÉn khai Production",
                  description: $description,
                  color: ($color | tonumber),
                  fields: [
                    { name: "üìä Tr·∫°ng th√°i", value: "\($icon) \($status | ascii_upcase)", inline: true },
                    { name: "üåø Nh√°nh", value: "`\($branch)`", inline: true },
                    { name: "üë§ Ng∆∞·ªùi th·ª±c hi·ªán", value: "`\($actor)`", inline: true },
                    { name: "‚è±Ô∏è Performance", value: "Build: \($build_time)s\nDeploy: \($deploy_time)s\nHealth: \($health_time)s\n**Total: \($total_time)s**", inline: false },
                    { name: "üîó Commit HEAD", value: "[`\($commit_short)`](https://github.com/\($repo)/commit/\($commit_full))", inline: false },
                    { name: "üìù N·ªôi dung HEAD", value: "\($commit_message)", inline: false },
                    { name: "üìö Danh s√°ch commits", value: $commits_block, inline: false },
                    { name: "üñºÔ∏è Image", value: "Tags:\n`\($image_tags)`\nDigest:\n`\($image_digest)`", inline: false }
                  ],
                  url: "https://github.com/\($repo)/actions/runs/\($run_id)",
                  footer: { "text": "üöÄ Tri·ªÉn khai Production ‚Ä¢ \($commit_date)" },
                  timestamp: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
                }]
              }')

          curl -s -H "Content-Type: application/json" -X POST -d "$JSON_PAYLOAD" "$DISCORD_WEBHOOK" || echo "L·ªói g·ª≠i th√¥ng b√°o Discord"

  # ==============================================
  # AUTOMATIC ROLLBACK
  # ==============================================
  rollback:
    name: üîÑ Auto Rollback
    needs: [deploy, health-check]
    runs-on: ubuntu-latest
    if: failure() && needs.deploy.result == 'success'
    timeout-minutes: 10
    steps:
      - name: üîÑ Rollback to previous commit
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            export PROJECT_PATH='${{ env.VPS_PATH }}'
            set -euo pipefail
            cd "$PROJECT_PATH"

            echo "üîÑ Starting automatic rollback..."

            # Rollback to previous commit
            git fetch --all --tags
            git reset --hard HEAD~1

            # Get branch and digest
            BRANCH=$(git rev-parse --abbrev-ref HEAD)
            DIGEST_TAG="$BRANCH-$(git rev-parse HEAD)"
            export SERVER_IMAGE="ghcr.io/${{ env.IMAGE_NAME }}:${DIGEST_TAG}"

            echo "üîÑ Rolling back to: $SERVER_IMAGE"

            # Redeploy previous version
            docker compose --env-file .env.docker pull
            docker compose --env-file .env.docker down
            docker compose --env-file .env.docker up -d --force-recreate

            echo "‚úÖ Rollback completed successfully"
