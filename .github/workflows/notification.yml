name: ğŸ“¢ Send Notification

on:
  workflow_run:
    workflows: ['ğŸš€ Deploy to Production']
    types: [completed]
    branches: [main, master]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: tedydev-web/server-shopsifu
  VPS_HOST: ${{ secrets.VPS_HOST }}
  VPS_USERNAME: ${{ secrets.VPS_USERNAME }}
  VPS_PATH: ${{ secrets.VPS_PATH }}

jobs:
  notification:
    name: ğŸ“¢ Send Notification
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: always()
    steps:
      - name: ğŸ“¥ Checkout repository for commit info
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ“¢ Send Discord notification
        uses: appleboy/ssh-action@v0.1.10
        with:
          host: ${{ env.VPS_HOST }}
          username: ${{ env.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          timeout: 60s
          command_timeout: 120s
          script: |
            set -euo pipefail

            # Set environment variables
            export DISCORD_WEBHOOK="${{ secrets.DISCORD_WEBHOOK }}"
            export STATUS="${{ github.event.workflow_run.conclusion == 'success' && 'success' || 'failure' }}"
            export BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"
            export ACTOR="${{ github.event.workflow_run.actor.login || github.actor }}"
            export COMMIT_SHA="${{ github.event.workflow_run.head_sha || github.sha }}"

            # Get detailed error information if deployment failed
            if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
              export ERROR_DETAILS="${{ github.event.workflow_run.conclusion }}"
              export FAILURE_REASON="${{ github.event.workflow_run.conclusion == 'failure' && 'Deployment failed' || github.event.workflow_run.conclusion == 'cancelled' && 'Deployment cancelled' || github.event.workflow_run.conclusion == 'timed_out' && 'Deployment timed out' || 'Deployment failed with unknown reason' }}"
            else
              export ERROR_DETAILS=""
              export FAILURE_REASON=""
            fi

            # Get commit message and date from workflow_run event
            export COMMIT_MESSAGE="${{ github.event.workflow_run.head_commit.message || 'Deployment from build workflow' }}"
            export COMMIT_DATE="${{ github.event.workflow_run.head_commit.timestamp || github.event.workflow_run.created_at || '' }}"

            export REPO="${{ github.repository }}"
            export RUN_ID="${{ github.run_id }}"
            export DEPLOY_TIME="${{ github.event.workflow_run.run_duration || 'N/A' }}"

            # Change to project directory
            cd "${{ env.VPS_PATH }}" || exit 1

            # Install jq if not present
            sudo apt-get update -qq
            sudo apt-get install -y -qq jq

            # Get commit information
            COMMIT_SHORT_SHA=$(echo "$COMMIT_SHA" | cut -c1-7)

            # Get commit list for this specific push - using GitHub context
            if [ "${{ github.event_name }}" = "workflow_run" ]; then
              # For workflow_run events, get commits from the triggering workflow
              # Check if before and after are available and valid
              BEFORE_SHA="${{ github.event.workflow_run.before || '' }}"
              AFTER_SHA="${{ github.event.workflow_run.after || '' }}"
              
              echo "ğŸ” Debug: Git context for workflow_run:"
              echo "  BEFORE_SHA: '$BEFORE_SHA'"
              echo "  AFTER_SHA: '$AFTER_SHA'"
              echo "  Event name: ${{ github.event_name }}"
              echo "  Workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
              echo "  Workflow status: ${{ github.event.workflow_run.status }}"
              echo "  Head SHA: ${{ github.event.workflow_run.head_sha || 'N/A' }}"
              
              # Try to get commit info from workflow_run context first
              if [ -n "$BEFORE_SHA" ] && [ -n "$AFTER_SHA" ] && [ "$BEFORE_SHA" != "0000000000000000000000000000000000000000" ]; then
                echo "âœ… Using before..after range for git commands"
                COMMIT_LIST=$(git log --oneline --no-merges "$BEFORE_SHA..$AFTER_SHA" | sed 's/^/â€¢ /' 2>/dev/null || echo "â€¢ Commits from this push (git log unavailable)")
                CHANGES_SUMMARY=$(git diff --stat "$BEFORE_SHA..$AFTER_SHA" | tail -1 | sed 's/^ //' 2>/dev/null || echo "Changes from this push (git diff unavailable)")
              else
                echo "âš ï¸ Falling back to recent commits (before/after not available or invalid)"
                # Try to get commits from head_sha if available
                HEAD_SHA="${{ github.event.workflow_run.head_sha || '' }}"
                if [ -n "$HEAD_SHA" ]; then
                  echo "ğŸ”„ Trying to get commits from head SHA: $HEAD_SHA"
                  COMMIT_LIST=$(git log --oneline --no-merges -5 "$HEAD_SHA" | sed 's/^/â€¢ /' 2>/dev/null || echo "â€¢ Recent commits from head SHA (git log unavailable)")
                  CHANGES_SUMMARY=$(git log --stat --oneline -5 "$HEAD_SHA" | grep -E "^ [0-9]+ files? changed" | tail -1 2>/dev/null || echo "Changes from head SHA (git log unavailable)")
                else
                  echo "ğŸ”„ Using generic recent commits fallback"
                  # Fallback to recent commits if before/after not available or invalid
                  COMMIT_LIST=$(git log --oneline --no-merges -5 | sed 's/^/â€¢ /' 2>/dev/null || echo "â€¢ Recent commits (git log unavailable)")
                  CHANGES_SUMMARY=$(git log --stat --oneline -5 | grep -E "^ [0-9]+ files? changed" | tail -1 2>/dev/null || echo "Changes detected (git log unavailable)")
                fi
              fi
            else
              echo "ğŸ” Debug: Using manual dispatch fallback"
              # For manual dispatch, get recent commits
              COMMIT_LIST=$(git log --oneline --no-merges -5 | sed 's/^/â€¢ /' 2>/dev/null || echo "â€¢ Recent commits (git log unavailable)")
              CHANGES_SUMMARY=$(git log --stat --oneline -5 | grep -E "^ [0-9]+ files? changed" | tail -1 2>/dev/null || echo "Changes detected (git log unavailable)")
            fi

            echo "ğŸ” Debug: Final commit info:"
            echo "  COMMIT_LIST: $COMMIT_LIST"
            echo "  CHANGES_SUMMARY: $CHANGES_SUMMARY"

            # Ensure we have valid commit info
            if [ -z "$COMMIT_LIST" ] || [ "$COMMIT_LIST" = "â€¢ Commits from this push (git log unavailable)" ] || [ "$COMMIT_LIST" = "â€¢ Recent commits (git log unavailable)" ] || [ "$COMMIT_LIST" = "â€¢ Recent commits from head SHA (git log unavailable)" ]; then
              echo "âš ï¸ Warning: Commit list is empty or invalid, using fallback"
              COMMIT_LIST="â€¢ Commit info unavailable - using fallback"
            fi

            if [ -z "$CHANGES_SUMMARY" ] || [ "$CHANGES_SUMMARY" = "Changes from this push (git diff unavailable)" ] || [ "$CHANGES_SUMMARY" = "Changes detected (git log unavailable)" ] || [ "$CHANGES_SUMMARY" = "Changes from head SHA (git log unavailable)" ]; then
              echo "âš ï¸ Warning: Changes summary is empty or invalid, using fallback"
              CHANGES_SUMMARY="Changes summary unavailable - using fallback"
            fi

            # Get Docker status with smart formatting for Discord
            DOCKER_STATUS_RAW=$(docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" | head -8 2>/dev/null || echo "Docker status unavailable")

            # Check if we can fit table format, otherwise use list format
            if [ "$(echo "$DOCKER_STATUS_RAW" | wc -c)" -lt 800 ]; then
              # Use table format if small enough
              DOCKER_STATUS=$(echo "$DOCKER_STATUS_RAW" | sed 's/  */ | /g' | sed 's/| |/|/g' | sed 's/Up [0-9]* seconds/Up/g' | sed 's/Up [0-9]* minutes/Up/g' | sed 's/Up [0-9]* hours/Up/g' | tr '\n' ' ')
            else
              # Use list format for better readability
              DOCKER_STATUS=$(echo "$DOCKER_STATUS_RAW" | tail -n +2 | while read -r name status ports; do
                if [ -n "$name" ]; then
                  echo "â€¢ $name: $status | $ports"
                fi
              done | head -6)
            fi

            # Get info for the specific deployed image
            DEPLOYED_IMAGE_FULL_NAME="${REGISTRY}/${IMAGE_NAME}:master-${COMMIT_SHORT_SHA}"
            DEPLOYED_IMAGE_SIZE=$(docker images --format "{{.Size}}" "$DEPLOYED_IMAGE_FULL_NAME" 2>/dev/null || echo "N/A")

            if [ "$DEPLOYED_IMAGE_SIZE" != "N/A" ]; then
              IMAGE_INFO="â€¢ Image: \`${DEPLOYED_IMAGE_FULL_NAME}\`\nâ€¢ Size: \`${DEPLOYED_IMAGE_SIZE}\`\nâ€¢ Tag: \`master-${COMMIT_SHORT_SHA}\`\nâ€¢ Registry: \`${REGISTRY}\`\nâ€¢ Install: \`docker pull ${DEPLOYED_IMAGE_FULL_NAME}\`"
            else
              # Fallback: try to get latest image info
              LATEST_IMAGE_SIZE=$(docker images --format "{{.Size}}" "${REGISTRY}/${IMAGE_NAME}:latest" 2>/dev/null || echo "N/A")
              if [ "$LATEST_IMAGE_SIZE" != "N/A" ]; then
                IMAGE_INFO="â€¢ Image: \`${REGISTRY}/${IMAGE_NAME}:latest\`\nâ€¢ Size: \`${LATEST_IMAGE_SIZE}\`\nâ€¢ Tag: \`latest\`\nâ€¢ Registry: \`${REGISTRY}\`\nâ€¢ Install: \`docker pull ${REGISTRY}/${IMAGE_NAME}:latest\`"
              else
                IMAGE_INFO="â€¢ Deployed image info unavailable or not found locally on VPS."
              fi
            fi

            # Get system info with better formatting
            SYSTEM_INFO=$(echo "CPU: $(nproc) cores\nMemory: $(free -h | grep Mem | awk '{print $2}')\nDisk: $(df -h / | tail -1 | awk '{print $4}') available" 2>/dev/null || echo "System info unavailable")

            # Get deployment environment info with better formatting
            ENV_INFO=$(echo "Host: $(hostname)\nOS: $(lsb_release -d | cut -f2)\nUptime: $(uptime -p)" 2>/dev/null || echo "Environment info unavailable")

            # Get network info with better formatting
            NETWORK_INFO=$(echo "IP: $(hostname -I | awk '{print $1}')\nGateway: $(ip route | grep default | awk '{print $3}' | head -1)" 2>/dev/null || echo "Network info unavailable")

            COLOR=$([ "$STATUS" = "success" ] && echo 3066993 || echo 15158332)
            ICON=$([ "$STATUS" = "success" ] && echo "âœ…" || echo "âŒ")
            DESCRIPTION=$([ "$STATUS" = "success" ] && echo "ğŸš€ **Deploy thÃ nh cÃ´ng**" || echo "âŒ **Deploy tháº¥t báº¡i**")

            # Handle empty values
            COMMIT_MESSAGE="${COMMIT_MESSAGE:-'Deployment from build workflow'}"
            COMMIT_DATE="${COMMIT_DATE:-$(date -u +"%Y-%m-%dT%H:%M:%SZ")}"
            DEPLOY_TIME="${DEPLOY_TIME:-'N/A'}"
            ERROR_DETAILS="${ERROR_DETAILS:-''}"
            FAILURE_REASON="${FAILURE_REASON:-''}"

            # Validate and sanitize values for JSON - improved sanitization with Discord formatting
            COMMIT_MESSAGE=$(echo "$COMMIT_MESSAGE" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 1000)
            COMMIT_DATE=$(echo "$COMMIT_DATE" | tr -d '\n\r' | head -c 100)
            DEPLOY_TIME=$(echo "$DEPLOY_TIME" | tr -d '\n\r' | head -c 50)
            COMMIT_LIST=$(echo "$COMMIT_LIST" | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 800)
            CHANGES_SUMMARY=$(echo "$CHANGES_SUMMARY" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 200)
            DOCKER_STATUS=$(echo "$DOCKER_STATUS" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | sed 's/Up [0-9]* seconds/Up/g' | head -c 1000)
            IMAGE_INFO=$(echo "$IMAGE_INFO" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 500)
            SYSTEM_INFO=$(echo "$SYSTEM_INFO" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 200)
            ENV_INFO=$(echo "$ENV_INFO" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 300)
            NETWORK_INFO=$(echo "$NETWORK_INFO" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 200)
            ERROR_DETAILS=$(echo "$ERROR_DETAILS" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 200)
            FAILURE_REASON=$(echo "$FAILURE_REASON" | tr -d '\n\r' | sed 's/"/\\"/g' | sed 's/\\/\\\\/g' | sed 's/  */ /g' | head -c 300)

            # Debug: Print sanitized values
            echo "ğŸ” Debug: Sanitized values:"
            echo "  COMMIT_MESSAGE: $COMMIT_MESSAGE"
            echo "  COMMIT_DATE: $COMMIT_DATE"
            echo "  DEPLOY_TIME: $DEPLOY_TIME"
            echo "  ERROR_DETAILS: $ERROR_DETAILS"
            echo "  FAILURE_REASON: $FAILURE_REASON"
            echo "  SYSTEM_INFO: $SYSTEM_INFO"
            echo "  ENV_INFO: $ENV_INFO"
            echo "  NETWORK_INFO: $NETWORK_INFO"

            # Create a summary of all collected information
            echo "ğŸ“‹ Summary of collected information:"
            echo "  Status: $STATUS"
            echo "  Branch: $BRANCH"
            echo "  Actor: $ACTOR"
            echo "  Commit SHA: $COMMIT_SHORT_SHA"
            echo "  Commit Message: $COMMIT_MESSAGE"
            echo "  Commit Date: $COMMIT_DATE"
            echo "  Deploy Time: $DEPLOY_TIME"
            if [ -n "$ERROR_DETAILS" ]; then
              echo "  Error Details: $ERROR_DETAILS"
              echo "  Failure Reason: $FAILURE_REASON"
            fi
            echo "  Repo: $REPO"
            echo "  Run ID: $RUN_ID"
            echo "  Discord Webhook: ${DISCORD_WEBHOOK:0:50}..."
            echo "  Total fields: $([ -n "$ERROR_DETAILS" ] && echo "15" || echo "13")"

            # Create smart JSON payload based on content size
            if [ "$(echo "$DOCKER_STATUS" | wc -c)" -gt 800 ]; then
              # Use compact format for large content
              JSON_PAYLOAD=$(jq -n \
                --arg status "$STATUS" \
                --arg icon "$ICON" \
                --arg description "$DESCRIPTION" \
                --arg color "$COLOR" \
                --arg branch "$BRANCH" \
                --arg actor "$ACTOR" \
                --arg commit_sha "$COMMIT_SHORT_SHA" \
                --arg commit_message "$COMMIT_MESSAGE" \
                --arg changes_summary "$CHANGES_SUMMARY" \
                --arg commit_list "$COMMIT_LIST" \
                --arg docker_status "$DOCKER_STATUS" \
                --arg deploy_time "$DEPLOY_TIME" \
                --arg error_details "$ERROR_DETAILS" \
                --arg failure_reason "$FAILURE_REASON" \
                --arg repo "$REPO" \
                --arg run_id "$RUN_ID" \
                ' {
                    embeds: [{
                      title: "ğŸš€ SERVER - Deploy Production",
                      description: $description,
                      color: ($color | tonumber),
                      fields: [
                        { name: "ğŸ“Š Tráº¡ng thÃ¡i", value: "\($icon) \($status | ascii_upcase)", inline: true },
                        { name: "ğŸŒ¿ NhÃ¡nh", value: $branch, inline: true },
                        { name: "ğŸ‘¤ NgÆ°á»i thá»±c hiá»‡n", value: $actor, inline: true },
                        { name: "ğŸ”— Commit SHA", value: "`\($commit_sha)`", inline: true },
                        { name: "â±ï¸ Deploy Time", value: $deploy_time, inline: true },
                        { name: "ğŸ“ Commit Message", value: $commit_message, inline: false },
                        { name: "ğŸ“Š Changes Summary", value: $changes_summary, inline: false },
                        { name: "ğŸ“‹ Danh sÃ¡ch Commits", value: "```\($commit_list)```", inline: false },
                        { name: "ğŸ³ Docker Status", value: "```\($docker_status)```", inline: false }
                        $([ -n "$ERROR_DETAILS" ] && echo '{ name: "ğŸš¨ Error Details", value: $error_details, inline: false },' || echo '') \
                        $([ -n "$ERROR_DETAILS" ] && echo '{ name: "âŒ Failure Reason", value: $failure_reason, inline: false },' || echo '') \
                      ],
                      url: "https://github.com/\($repo)/actions/runs/\($run_id)",
                      footer: { "text": "ğŸš€ Deploy Production (Compact)" },
                      timestamp: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
                    }]
                  }')
            else
              # Use full format for smaller content
              JSON_PAYLOAD=$(jq -n \
                --arg status "$STATUS" \
                --arg icon "$ICON" \
                --arg description "$DESCRIPTION" \
                --arg color "$COLOR" \
                --arg branch "$BRANCH" \
                --arg actor "$ACTOR" \
                --arg commit_sha "$COMMIT_SHORT_SHA" \
                --arg commit_message "$COMMIT_MESSAGE" \
                --arg commit_date "$COMMIT_DATE" \
                --arg changes_summary "$CHANGES_SUMMARY" \
                --arg commit_list "$COMMIT_LIST" \
                --arg docker_status "$DOCKER_STATUS" \
                --arg image_info "$IMAGE_INFO" \
                --arg system_info "$SYSTEM_INFO" \
                --arg deploy_time "$DEPLOY_TIME" \
                --arg repo "$REPO" \
                --arg run_id "$RUN_ID" \
                --arg env_info "$ENV_INFO" \
                --arg network_info "$NETWORK_INFO" \
                --arg error_details "$ERROR_DETAILS" \
                --arg failure_reason "$FAILURE_REASON" \
                ' {
                    embeds: [{
                      title: "ğŸš€ SERVER - Deploy Production",
                      description: $description,
                      color: ($color | tonumber),
                      fields: [
                        { name: "ğŸ“Š Tráº¡ng thÃ¡i", value: "\($icon) \($status | ascii_upcase)", inline: true },
                        { name: "ğŸŒ¿ NhÃ¡nh", value: $branch, inline: true },
                        { name: "ğŸ‘¤ NgÆ°á»i thá»±c hiá»‡n", value: $actor, inline: true },
                        { name: "ğŸ”— Commit SHA", value: "`\($commit_sha)`", inline: true },
                        { name: "ğŸ“… Commit Date", value: $commit_date, inline: true },
                        { name: "â±ï¸ Deploy Time", value: $deploy_time, inline: true },
                        { name: "ğŸ“ Commit Message", value: $commit_message, inline: false },
                        { name: "ğŸ“Š Changes Summary", value: $changes_summary, inline: false },
                        { name: "ğŸ“‹ Danh sÃ¡ch Commits", value: "```\($commit_list)```", inline: false },
                        { name: "ğŸ³ Docker Status", value: "```\($docker_status)```", inline: false },
                        { name: "ğŸ–¼ï¸ Image Info", value: "$image_info", inline: false },
                        { name: "ğŸ’» System Info", value: "```\($system_info)```", inline: false },
                        { name: "ğŸŒ MÃ´i trÆ°á»ng", value: "```\($env_info)```", inline: false },
                        { name: "ğŸŒ Máº¡ng", value: "```\($network_info)```", inline: false }
                        $([ -n "$ERROR_DETAILS" ] && echo '{ name: "ğŸš¨ Error Details", value: $error_details, inline: false },' || echo '') \
                        $([ -n "$ERROR_DETAILS" ] && echo '{ name: "âŒ Failure Reason", value: $failure_reason, inline: false },' || echo '') \
                      ],
                      url: "https://github.com/\($repo)/actions/runs/\($run_id)",
                      footer: { "text": "ğŸš€ Deploy Production (Full)" },
                      timestamp: (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
                    }]
                  }')
            fi

            # Debug: Print JSON payload
            echo "ğŸ” Debug: JSON Payload:"
            echo "$JSON_PAYLOAD"

            # Validate JSON payload with detailed error reporting
            if ! echo "$JSON_PAYLOAD" | jq . >/dev/null 2>&1; then
              echo "âŒ Invalid JSON payload generated"
              echo "âŒ JSON validation failed"
              echo "âŒ JSON validation error:"
              echo "$JSON_PAYLOAD" | jq . 2>&1 || true
              echo "âŒ Please check the generated JSON payload"
              exit 1
            fi

            # Additional JSON structure validation
            if ! echo "$JSON_PAYLOAD" | jq '.embeds[0].fields' >/dev/null 2>&1; then
              echo "âŒ Invalid embed structure in JSON payload"
              echo "âŒ Embed validation failed"
              exit 1
            fi

            # Check JSON payload size (Discord has a limit of 6000 characters for embeds)
            PAYLOAD_SIZE=$(echo "$JSON_PAYLOAD" | wc -c)
            if [ "$PAYLOAD_SIZE" -gt 5000 ]; then
              echo "âš ï¸ Warning: JSON payload is large ($PAYLOAD_SIZE bytes)"
              echo "âš ï¸ Discord has embed limits, some content may be truncated"
            fi

            # Validate Discord webhook URL (allow both discord.com and canary.discord.com)
            if [[ ! "$DISCORD_WEBHOOK" =~ ^https://(discord\.com|canary\.discord\.com)/api/webhooks/[0-9]+/[a-zA-Z0-9_-]+$ ]]; then
              echo "âŒ Invalid Discord webhook URL format"
              echo "âŒ Expected format: https://discord.com/api/webhooks/[ID]/[TOKEN] or https://canary.discord.com/api/webhooks/[ID]/[TOKEN]"
              exit 1
            fi

            # Send to Discord with retry logic
            MAX_RETRIES=3
            for i in $(seq 1 $MAX_RETRIES); do
              echo "ğŸ”„ Attempting to send Discord notification (attempt $i/$MAX_RETRIES)..."
              echo "ğŸ”— Discord webhook: ${DISCORD_WEBHOOK:0:50}..."
              echo "ğŸ“¦ Payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"

              RESPONSE=$(curl -s -w "\nHTTP_STATUS:%{http_code}" -H "Content-Type: application/json" -X POST -d "$JSON_PAYLOAD" "$DISCORD_WEBHOOK")
              HTTP_STATUS=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)
              RESPONSE_BODY=$(echo "$RESPONSE" | grep -v "HTTP_STATUS:")

              echo "ğŸ” Debug: HTTP Status: $HTTP_STATUS"
              echo "ğŸ” Debug: Response Body: $RESPONSE_BODY"

              if [ "$HTTP_STATUS" = "204" ] || [ "$HTTP_STATUS" = "200" ]; then
                echo "âœ… Discord notification sent successfully (HTTP $HTTP_STATUS)"
                echo "âœ… Notification sent to Discord channel"
                echo "âœ… Payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"
                echo "âœ… Response: $RESPONSE_BODY"
                break
              else
                echo "âš ï¸ Attempt $i/$MAX_RETRIES failed (HTTP $HTTP_STATUS)"
                echo "âš ï¸ Response: $RESPONSE_BODY"
                if [ $i -lt $MAX_RETRIES ]; then
                  echo "â³ Waiting 2 seconds before retry..."
                  sleep 2
                else
                  echo "âŒ Failed to send Discord notification after $MAX_RETRIES attempts"
                  echo "âŒ Last response: $RESPONSE_BODY"
                  echo "âŒ Discord webhook URL: $DISCORD_WEBHOOK"
                  echo "âŒ Please check your Discord webhook configuration"
                  echo "âŒ Payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"
                  echo "âŒ HTTP Status: $HTTP_STATUS"
                  exit 1
                fi
              fi
            done

            echo "ğŸ‰ Discord notification process completed"
            echo "ğŸ“Š Final status: $STATUS"
            echo "â±ï¸ Total time: $DEPLOY_TIME"
            echo "ğŸ“¦ Final payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"

            # Fallback: Create a simple notification file for manual review
            NOTIFICATION_FILE="/tmp/deploy_notification_$(date +%Y%m%d_%H%M%S).json"
            echo "$JSON_PAYLOAD" > "$NOTIFICATION_FILE"
            echo "ğŸ“ Fallback notification saved to: $NOTIFICATION_FILE"
            echo "ğŸ“ You can manually review the notification content"

            # Final success message
            echo "ğŸ‰ Discord notification process completed successfully"
            echo "ğŸ“Š Final status: $STATUS"
            echo "â±ï¸ Total time: $DEPLOY_TIME"
            echo "ğŸ“¦ Final payload size: $(echo "$JSON_PAYLOAD" | wc -c) bytes"
            echo "âœ… All operations completed without errors"
